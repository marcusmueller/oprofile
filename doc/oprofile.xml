<?xml version="1.0" encoding='ISO-8859-1'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<book id="oprofile-guide">
<bookinfo>
	<title>OProfile manual</title>
 
	<authorgroup>
		<author>
			<firstname>John</firstname>
			<surname>Levon</surname>
			<affiliation>
				<address><email>moz@compsoc.man.ac.uk</email></address>
			</affiliation>
		</author>
	</authorgroup>

	<copyright>
		<year>2000-2002</year>
		<holder>Victoria University of Manchester, John Levon and others</holder>
	</copyright>

</bookinfo>

<toc></toc>

<chapter id="introduction">
<title>Introduction</title>

<para>
OProfile is a profiling system for Linux 2.2/2.4 systems on most x86 processors. It is capable of profiling
all parts of a running system, from the kernel (including modules and interrupt handlers) to shared libraries
to binaries. It runs transparently in the background collecting information at a low overhead. These
features make it ideal for profiling entire systems in production environments to determine bottle
necks in real-world systems.
</para>

<sect1 id="requirements">
<title>System requirements</title>

<variablelist>
	<varlistentry>
		<term>Linux kernel 2.2/2.4</term>
		<listitem>
			OProfile uses a kernel module that can be compiled for 2.2.11 or later and 2.4. Support for 2.5 up to 2.5.2 is also provided.
			Versions 2.4.10 or above are recommended, and required if you use the
			boot-time kernel option <option>nosmp</option>.
<!-- FIXME: do we require always gte 2.4.10 for nosmp ? -->
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>modutils 2.4.6 or above</term>
		<listitem>
			You should have installed modutils 2.4.6 or higher (in fact earlier versions work well in almost all
			cases).
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>Intel P6 processor or AMD Athlon/Duron.</term>
		<listitem>
			A CPU with a P6 generation core is required. In marketing terms this translates to anything between an Intel
			Pentium Pro (NOT Pentium Classics) and a Pentium III, including all Celerons.
			The AMD Athlon &amp; Duron CPUs are also supported.
			Other CPU types only support the RTC mode of oprofile, please see later in this manual for details. 
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>Uniprocessor or SMP</term>
		<listitem>
			SMP machines are also supported in both Intel and AMD variants.
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>Required libraries</term>
		<listitem>
			These libraries are required : <filename>popt</filename>, <filename>bfd</filename>,
			<filename>liberty</filename>, <filename>dl</filename>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>Bash version 2</term>
		<listitem>
			The <command>op_start</command> script requires bash version 2 at least to be installed
			as <filename>/bin/bash</filename> or <filename>/bin/bash2</filename>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>OProfile GUI</term>
		<listitem>
			The use of the GUI to start the profiler requires the <filename>Qt 2</filename> library. Qt 3 should
			also work.
		</listitem>
	</varlistentry>
	<varlistentry>
 		<term><acronym>ELF</acronym></term>
		<listitem>
			Probably not too strenuous a requirement, but older <acronym>A.OUT</acronym> binaries/libraries are not supported.
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>K&amp;R coding style</term>
		<listitem>
			OK, so it's not really a requirement, but I wish it was...
		</listitem>
	</varlistentry>
</variablelist>


</sect1>

<sect1 id="resources">
<title>Internet resources</title>

<variablelist>
	<varlistentry>
		<term>Web page</term>
		<listitem>
			There is a web page (which you may be reading now) at
			<ulink url="http://oprofile.sf.net/">http://oprofile.sf.net/</ulink>.
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>Download</term>
		<listitem>
			You can download a source tarball or get anonymous CVS at the sourceforge page,
			<ulink url="http://sf.net/projects/oprofile/">http://sf.net/projects/oprofile/</ulink>.
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>Mailing list</term>
		<listitem>
			There is a very low-traffic OProfile-specific mailing list, details at
			<ulink url="http://sf.net/mail/?group_id=16191">http://sf.net/mail/?group_id=16191</ulink>.
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>Bug tracker</term>
		<listitem>
			There is a bug tracker for OProfile at the sourceforge page,
			<ulink url="http://sf.net/tracker/?group_id=16191&amp;atid=116191">http://sf.net/tracker/?group_id=16191&amp;atid=116191</ulink>.
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>IRC channel</term>
		<listitem>
			Several oprofile developers and users sometimes hang out on channel <command>#oprofile</command>
			at <ulink url="http://www.openprojects.net/">openprojects.net</ulink>. 
		</listitem>
	</varlistentry>
</variablelist>

</sect1>

<sect1 id="install">
<title>Installation</title>

First you need to build <filename>oprofile</filename> and install it. <command>./configure</command>, <command>make</command>, <command>make install</command>
is all you need, but note these arguments to <command>./configure</command> :
<variablelist>
	<varlistentry>
		<term><option>--with-linux</option></term>
		<listitem>
			Use this option to specify the location of the kernel source tree you wish
			to compile against. The kernel module is built against this source and
			will only work with a running kernel built from the same source with
			similar options, so it is important you specify this option if you need
			to.
		</listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--with-qt2-dir/includes/libraries</option></term>
		<listitem>
			Specify the location of Qt2 headers and libraries. It defaults to searching in
			<constant>$QTDIR</constant> if these are not specified.
		</listitem>
	</varlistentry>
</variablelist>
<para>
You'll need to have a configured kernel source for the current kernel
to build the module.  It is also recommended that if you have a
uniprocessor machine, you enable the local APIC / IO_APIC support for
your kernel (this is automatically enabled for SMP kernels).  On
machines with power management, such as laptops, the power management
must be turned off when using OProfile. The power management software
in the BIOS cannot handle the non-maskable interrupts (NMIs) used by
OProfile for data collection.
</para>

</sect1>

<sect1 id="uninstall">
<title>Uninstalling oprofile</title>
<para>
You must have the source tree available to uninstall oprofile; a <command>make uninstall</command> will
remove all installed files except your configuration file in the directory <filename>~/.oprofile</filename>.
</para>
</sect1>

</chapter>

<chapter id="overview"> 
<title>Overview of oprofile tools</title>
<para>
This section gives a brief description of the available oprofile utilities and their purpose.
</para>
<variablelist>
<varlistentry>
	<term><filename>op_help</filename></term>
	<listitem>
		This utility lists the available events and short descriptions.
	</listitem>
</varlistentry>
	
<varlistentry>
	<term><filename>op_start</filename>, <filename>oprof_start</filename></term>
	<listitem>
		Used for starting profiling, discussed in <xref linkend="usage" />.
	</listitem>
</varlistentry>

<varlistentry>
	<term><filename>op_stop</filename></term>
	<listitem><para>
		You should stop the profiler using this script. The profiler will collect
		all the data remaining to be processed, and quit.
	</para></listitem>
</varlistentry>

<varlistentry>
	<term><filename>op_dump</filename></term>
	<listitem><para>
		This causes the profiler to process all pending information.
	</para></listitem> 
</varlistentry>
 
<varlistentry>
	<term><filename>oprofpp</filename></term>
	<listitem><para>
		This is the main tool for retrieving useful profile data, described in
		<xref linkend="results" />.
	</para></listitem>
</varlistentry>

<varlistentry>
	<term><filename>op_time</filename></term>
	<listitem><para>
		This utility is useful for examining the relative profile values for
		all images on the system to determine the applications with the largest
		impact on system performance.
	</para></listitem>
</varlistentry>

<varlistentry>
	<term><filename>op_to_source</filename></term>
	<listitem><para>
		This utility can be used to produce annotated source, assembly or mixed source/assembly.
		Source level annotation is available only if the application was compiled with 
		debugging symbols. See <xref linkend="op-to-source" />.
	</para></listitem>
</varlistentry>

<varlistentry>
	<term><filename>op_merge</filename></term>
	<listitem><para>
		This utility is useful to merge samples files which belongs to the same application
		especially when you profile with separating samples for shared libs. See <xref linkend="op-merge" />.
	</para></listitem>
</varlistentry>

</variablelist>
	
</chapter>
 
<chapter id="usage">
<title>Usage</title>

<sect1 id="typical">
<title>A typical session</title>
<para>
Before getting into detail about usage, it's probably a good idea to have a quick stroll through an example
session (this example is for Intel processors not AMD, but the process is the same).
</para>
<para>
First we need to start the profiler running in the background. We need to pass the correct
<filename>vmlinux</filename> file to the daemon (to allow kernel profiling), and we need to specify what event to count and the counter value.
Here I've started with :
</para>
<para><command>op_start --vmlinux=/boot/2.4.0ac12/vmlinux  --ctr0-event=CPU_CLK_UNHALTED --ctr0-count=600000</command></para>
<para>
Here we've enabled counter 0 to count "CPU_CLK_UNHALTED" (number of cycles CPU is not halted) events with a count value of 600,000.
This event is useful as profiles resulting generally correspond to time-spent profiles for functions etc. 
</para>
<para>
A quick <command>ps ax</command> confirms that the daemon (<command>oprofiled</command>) has started.
Data is now being collected in the kernel. Now we can do whatever we like ... although in this case I'm profiling the C++ application
<ulink url="http://www.lyx.org/">LyX</ulink>.
Note that unlike <command>gprof</command>, no instrumentation (<option>-pg</option> and <option>-a</option> options to <command>gcc</command>)
is necessary. This is major factor in achieving the low overhead of OProfile. Compiling with debug symbols (the <option>-g</option>
option) is not necessary to get a basic function-based profile listing, but it must be used in order to retrieve line number
information and create annotated source.
</para>
<para>
Rather than wait for the buffers to fill up, I now force the profiling data to be processed with :
</para>
<para><command>op_dump</command></para>
<para>
which will ask the kernel module to dump as much data as it can to the daemon.
</para>
<note>
<para>Forcing a dump like this can cause the daemon to become very busy, especially the first time it is done. Don't worry,
that's not normal behaviour; so if you are profiling over a larger period of time, such spikes won't appear.
</para>
</note>
<para>
I can now ask for a symbol-based summary of the sample profile :
</para>
<para><command>oprofpp --demangle -l ./lyx &gt;oprof.out</command></para>
<para>
This can be quite slow on large binaries, so sit tight. 
As it's a C++ program, I asked for the symbols to be demangled to a readable form. Examining
the output will give the symbols against which the most hits were registered. In this case I got :
</para>
<screen>
...
Row::par(void)[0x0813ab54]: 5.4079% (472 samples)
LyXText::GetRow(LyXParagraph *, int, int &amp;) const[0x08170a4c]: 5.5683% (486 samples)
LyXParagraph::GetFontSettings(BufferParams const &amp;, int) const[0x08145420]: 5.7516% (502 samples)
Row::next(void) const[0x0813ac24]: 15.4904% (1352 samples)
</screen> 
<para>
at the top. Note that over a longer run (or with a lower <option>ctr0-count</option> value) the number of samples will 
be much more statistically
reliable. Note that these sample counts do <emphasis>not</emphasis> necessarily reflect the relative amounts of time
spent in each function - it depends on the event being counted. In this case we used <constant>CPU_CLK_UNHALTED</constant>
which the command <command>op_help</command> tells us is "clocks processor is not halted", so in fact is likely to represent
the relative time spent accurately (in fact, experiments have shown that using this event is far more accurate than the values
produced by <command>gprof</command>).
</para>
<note>
<para>
If you're more used to <command>gprof</command> style profile output, you can use <command>oprofpp -g gmon.out</command> and then
<command>gprof -p binary</command> to get flat profiles. OProfile does not (cannot) support the call graph
feature of <command>gprof</command>.
</para>
</note>

</sect1>

<sect1 id="starting-daemon">
<title>Starting profiling from the <command>op_start</command> script</title>
<para>
In this section the configuration and startup of the profiler is discussed in more depth.
</para>
<para>
A shell script <command>op_start</command> is provided to set up the correct
environment, insert the kernel module, and start up the profiler daemon.
OProfile stores its relevant files in <filename>/var/lib/oprofile</filename>.
Of most interest are the <filename>oprofiled.log</filename> log file, and the
<filename>samples/</filename> directory. The <filename>samples</filename>
directory contains the actual sample profile files created by the daemon.
Despite their apparent size they take up much less actual diskspace as they are
created sparsely (<command>stat</command> or <command>du [-h]</command> should tell you their real on-disk
size). Note than this imply we <emphasis>greatyl discourage</emphasis> use of filesystem without a
proper support for sparse file including vfat fs and many network fs.
 Each filename corresponds to the profiled binary image (with
<constant>/</constant> characters replaced with <constant>}</constant>
characters). In addition, each filename has a suffix indicating the counter
number.
The man page for <command>op_start</command> details the all the
options, only interesting ones are listed here : 
</para>
<variablelist>
	<varlistentry>
		<term><option>--list-events</option></term>
		<listitem><para>
		This gives a short list of the hardware events that are countable (see <xref linkend="hardware-counters" />).
		The meaning of options relating to the counters themselves is also detailed in that section.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--buffer-size=</option>nr</term>
		<listitem><para>
		This is the number of entries in the kernel-side profiling buffer. Generally the default value
		is fine: you might want to change this on low-memory machines, or if you are doing very detailed profiling.
		Each entry in the buffer takes 8 bytes.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--hash-table-size=</option>nr</term>
		<listitem><para>
		This is the number of entries in the kernel-side profiling hash table. Generally the default value
		is fine: you might want to change this on low-memory machines, or if you are doing very detailed profiling.
		Each entry in the hash table takes 32 bytes (4 samples for each entry).
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--note-table-size=</option>nr</term>
		<listitem><para>
		This is the number of entries in the kernel note table. Generally the default value
		is fine: you might want to change this on low-memory machines, or if you are doing very detailed profiling.
		Each entry in the buffer takes 20 bytes.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--kernel-only=</option>nr</term>
		<listitem><para>
		Default is to profile both user-space and the kernel. You can profile only the kernel with this option;
		this does not prevent the occasional user-space sample due to the hardware constraints, but reduces the
		overhead considerably.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--vmlinux=</option><filename>filename</filename></term>
		<listitem><para>
		Specify the <filename>vmlinux</filename> file from the current kernel's compile. This must match
		the running kernel if you expect meaningful profiles of the kernel. Note that this is a separate file
		from your kernel image (<filename>vmlinuz</filename>); you must specify the <filename>vmlinux</filename>
		file created during the kernel build in order to profile the kernel.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--separate-samples</option></term>
		<listitem><para>
		separate samples for each distinct application. With this option, samples
		in shared libraries are stored in a separate sample file specific to the
		primary binary image (e.g. /bin/cp) that the code is mapped into. This feature
		is not supported for process-context kernel samples, and incurs a performance
		penalty.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--pid-filter=</option>pid</term>
		<listitem><para>
		Only samples of this process id will be collected (including any kernel-side samples when this process is in
		the kernel). Note that threaded programs under Linux have a different process id for each thread.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--pgrp-filter=</option>pgpr</term>
		<listitem><para>
		Only samples of this process tty group id will be collected (including any kernel-side samples when this process is in
		the kernel).
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--verbose</option></term>
		<listitem><para>
		This makes the daemon <emphasis>very</emphasis> verbose in its logfile. Don't use this unless you need it
		as the overhead of logging the data is significant. It is however useful for determining profiler bugs
		(believe me ;)
		</para></listitem>
	</varlistentry>
</variablelist>
<para>
The runtime profiler system consists of two components: a kernel module (<filename>oprofile</filename>)
and a user-space daemon process (<filename>oprofiled</filename>). The kernel module collects sample data into
the hash table and buffer, and wakes up the daemon process when it is approaching full. The daemon will read this
data, and process it into a non-volatile form. Any samples are recorded into the sample files at processing time.
</para>
<para>
The <command>op_start</command> shell script will insert the kernel module if needed.
The profiling is activated when the daemon process initialises. Configuration of the kernel module parameters is done
via <command>sysctl</command>; the available files are detailed in <xref linkend="sysctl" />.
</para>

</sect1> 
 
<sect1 id="oprofile-gui">
<title>Starting profiling from the <command>oprofile</command> gui</title>
<para>
This section describes the <command>oprofile</command> Qt-based interface.
</para>
<para>
The <command>oprof_start</command> application provides a convenient way to start the profiler.
Note that <command>oprof_start</command> is just a wrapper around the <command>op_start</command> script,
so it does not provide more services than the script itself.
</para>
<para>
After <command>oprof_start</command> is started you can select the event type for each counter;
the sampling rate and other related parameters are explained in <xref linkend="starting-daemon" />.
The "Configuration" section allows you to set general parameters such as the buffer size, kernel filename
etc. The counter setup interface should be self-explanatory; <xref linkend="hardware-counters" /> and related 
links contain information on using unit masks.
</para>
<para>
A status line shows the current status of the profiler: how long it has been running, and the average
number of interrupts received per second and the total, over all processors.
Note that quitting <command>oprof_start</command> does not stop the profiler.
</para>
<para>
Your configuration is saved when you quit the gui in two files in ~/.oprofile directory :
<filename>oprof_start_config</filename> and <filename>oprof_start_event</filename>. These
contain the general configuration, and event/counter setup, respectively.
</para>

</sect1>

<sect1 id="sessions">
<title>Profiling sessions</title>
<para>
It can often be useful to split up profiling data into several different
time periods. For example, you may want to collect data on an application's
startup separately from the normal runtime data. You can use the simple to
tool <command>op_session</command> to do this. For example :
</para>
<screen>
op_session run1
</screen>
<para>
will create a sub-directory containing the samples up to that point (the current
session's sample files are moved into this directory). You can
then pass this name as, for example, a parameter to <command>op_time</command>
to only get data up to the point you named the session.
</para>
</sect1>
 
<sect1 id="detailed-parameters">
<title>Configuration details</title>

<sect2 id="hardware-counters">
<title>Hardware Performance Counters</title>
<note>
<para>
Your CPU type may not include the requisite support for hardware performance counters, in which case
you must use OProfile in RTC mode: see <xref linkend="rtc" />.
</para>
</note>
<para>
The hardware performance counters are detailed in the Intel IA-32 Architecture Manual, Volume 3, available
from <ulink url="http://developer.intel.com/">http://developer.intel.com/</ulink>. The AMD Athlon/Duron
implementation is detailed in <ulink url="http://www.amd.com/products/cpg/athlon/techdocs/pdf/22007.pdf">
http://www.amd.com/products/cpg/athlon/techdocs/pdf/22007.pdf</ulink>.
These processors are capable of delivering an interrupt to the local <acronym>APIC</acronym> <acronym>LVTPC</acronym>
vector when a counter overflows. This is the basic mechanism on which OProfile is based. The kernel module
installs an interrupt handler for this vector. The delivery mode is set to <acronym>NMI</acronym> so that
blocking interrupts in the kernel does not prevent profiling. When the interrupt handler is called,
the current <acronym>EIP</acronym> <acronym>PC</acronym> value, process id, and counter
are recorded into the profiling structure. This allows the overflow event to be attached
to a specific assembly instruction in a binary image. The daemon is necessary to transform these recorded
values into a count against a file offset for a given binary image, in order to produce profile data off-line
at a later time.
</para>
<para>
If we use an event such as <constant>CPU_CLK_UNHALTED</constant> or <constant>INST_RETIRED</constant>, we can
use the overflow counts as an estimate of actual time spent in each part of code. Alternatively we can
profile interesting data such as the cache behaviour of routines with the other available counters.
</para>
<para>
However there are several caveats. Firstly there are those issues listed in the Intel manual. There is a delay
between the counter overflow and the interrupt delivery that can skew results on a small scale - this means
you cannot rely on the profiles at the instruction level, except as a binary was/wasn't executed indicator.
If you are using an "event-mode" counter such as the cache counters, a count registered against it doesn't mean
that it is responsible for that event. However, it implies that the counter overflowed in the dynamic
vicinity of that instruction, to within a few instructions. Further details on this problem can be found in 
<xref linkend="interpreting" /> and also in
the Digital paper "ProfileMe: A Hardware Performance Counter". Also note that a very high number of interrupts
can have a large performance effect, and even overflow the profiling data structures. This can lead to mapping information
getting overwritten, and loss of respect from boxing promoter (don't worry, an obscure reference). The system
stability will never be affected, but profiling may not be able to work properly. An error message from the
kernel module will appear in your system log files if this situation occurs.
</para>
<para>
As described in the Intel manual, each counter, as well as being configured to count an event type, has several
more configuration parameters. First, there is the unit mask: this simply further specifies what to count.
Second, there is the counter value, discussed below. Third, there is a parameter whether to increment counts
whilst in kernel or user space. You can configure these separately for each counter.
</para>
<para>
So you must specify a counter value with the <option>--ctrX-count</option> option, where <option>X</option>
is the logical counter number in the range 0-3 (0-1 for Intel processors, which only have two counters). 
Using multiple counters is useful for profiling several aspects of the same running program.
After each overflow event, the counter will be re-initialized
such that another overflow will occur after this many events have been counted. Picking a good value for this
parameter is, unfortunately, somewhat of a grey art (not quite black). It is of course dependent on the event
you have chosen. For basic time-based profiling, you will probably use <constant>CPU_CLK_UNHALTED</constant>
(on Intel). 
You can estimate how many interrupts this value will generate per second with this event by dividing your CPU
clock rate by the chosen value. I have a 600MHz Celeron, so specifying an overflow value of 100,000 will generate
around 600 interrupts per second. Specifying too large a value will mean not enough interrupts are generated
to give a realistic profile (though this problem can be ameliorated by profiling for <emphasis>longer</emphasis>).
Specifying too small a value can lead to overflow problems discussed previously.
</para>

</sect2>

<sect2 id="rtc">
<title>OProfile in RTC mode</title>
<para>
Some CPU types do not provide the needed hardware support to use the hardware performance counters. This includes
some laptops, classic Pentiums, and other CPU types not yet supported by OProfile (such as Cyrix and Pentium IV). 
On these machines, OProfile falls
back to using the real-time clock interrupt to collect samples. This interrupt is also used by the <command>rtc</command>
module: you cannot have both the oprofile and rtc modules loaded nor the rtc support compiled in the kernel.
</para>
<para>
RTC mode is less capable than the hardware counters mode; in particular, it is unable to profile sections of
the kernel where interrupts are disabled. There is just one available event, "RTC interrupts", and its value 
corresponds to the number of interrupts generated per second (that is, a higher number means a better profiling
resolution, and higher overhead). The current implementation of the real-time clock supports only power-of-two
sampling rates from 2 to 4096 per second.  Other values within this range are rounded to the nearest power of
two.
</para>
<para>
Setting the value from the GUI should be straightforward. On the command line, you need to specify the
<option>--rtc-value</option> option to <command>op_start</command>, e.g. :
</para>
<para><command>op_start --vmlinux=/boot/2.4.0ac12/vmlinux --rtc-value=256</command></para>
<para>
Note the sysctl tree described in the next section is different when the RTC is being used.  In particular,
the file <filename>/proc/sys/dev/oprofile/rtc_value</filename> is used by the tools to set the desired RTC 
sampling rate, and will reflect the actual sampling rate after profiling has started.
</para>
</sect2>

<sect2 id="sysctl">
<title><command>sysctl</command> tree</title>
<para>
When the kernel module loads, it generates a file hierarchy underneath <filename>/proc/sys/dev/oprofile</filename>.
You can read and write to these files to give direct access to the kernel parameters.
</para>
<note>
<para>
With the exception of <filename>dump</filename> and <filename>dump_stop</filename>, 
any changes only take effect on restarting the profiler.
</para>
</note>
The following files will be present :
<variablelist>
	<varlistentry>
		<term><filename>bufsize</filename></term>
		<listitem><para>
		The buffer size, corresponding to the <option>--buffer-size</option> option.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>hashsize</filename></term>
		<listitem><para>
		The hash table size, corresponding to the <option>--hash-table-size</option> option.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>notesize</filename></term>
		<listitem><para>
		The note table size, corresponding to the <option>--note-table-size</option> option.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>kernel_only</filename></term>
		<listitem><para>
		Corresponding to the <option>--kernel-only</option> option.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>dump</filename></term>
		<listitem><para>
		Writing <acronym>ASCII</acronym> "1" to the file will initiate a sample data dump. Note: ignore
		the value "0" you get when reading the file - it is meaningless.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>dump_stop</filename></term>
		<listitem><para>
		Writing to this file will stop the profiler, processing all pending data, and stopping the user-space
		daemon.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>nr_interrupts</filename></term>
		<listitem><para>
		Read only; the number of total interrupts received on all processors since this file was last
		read. Used by the GUI.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>cpu_type</filename></term>
		<listitem><para>
		Read only; used internally by the oprofile tools.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>0, 1, ...</filename></term>
		<listitem><para>
		Each counter will have a directory containing files for that counter's settings.
		The rest of the files described here are per-counter.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>count</filename></term>
		<listitem><para>
		The counter value for this counter.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>enabled</filename></term>
		<listitem><para>
		Whether this counter is active.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>event</filename></term>
		<listitem><para>
		The numeric event value. You can convert from symbolic event names to numeric values like so :
		</para><para><command>echo `op_help CPU_CLK_UNHALTED` &gt;/proc/sys/dev/oprofile/0/0/event</command>.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>kernel</filename></term>
		<listitem><para>
		Whether to profile the kernel.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>unit_mask</filename></term>
		<listitem><para>
		The unit mask specified.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><filename>user</filename></term>
		<listitem><para>
		Whether to profile user-space.
		</para></listitem>
	</varlistentry>
</variablelist>

</sect2>

<sect2 id="misuse">
<title>Misuse of <command>oprofile</command> and stability of system</title>
<para>
OProfile is a low-level profiler which allow continuous profiling with a low-overhead cost.
If not used carefully, this can affect the stability of the system.
If too low a count reset value is set for a counter, the system can become overloaded with counter
interrupts, and seem as if the system has frozen.
</para>
<note><para>
This can happen as follows: When the profiler count
reaches zero an NMI handler is called which stores the sample values in an internal buffer, then resets the counter
to its original value. If the count is very low, a pending NMI can be sent before the NMI handler has
completed. Due to the priority of the NMI, the local APIC delivers the pending interrupt immediately after
completion of the previous interrupt handler, and control never returns to other parts of the system.
In this way the system seems to be frozen.
</para></note>
<para>If this happens, it will be impossible to bring the system back to a workable state.
There is no way to provide real security against this happening, other than making sure to use a reasonable value
for the counter reset. For example, setting CPU_CLK_UNHALTED event type with a ridiculously low reset count (e.g. 500)
is likely to freeze the system.
</para>
<para>
In short : <command>Don't try a foolish sample count value.</command> Unfortunately the definition of a foolish value
is really dependent on the event type - if ever in doubt, e-mail </para>
<address><email>oprofile-list@lists.sf.net</email>.</address>
<para>Do I hear you shout "but my event value is low, but not stupid !" ? Yes, this can be the case. In these
circumstances, a simple solution is to disable kernel profiling by turning off the kernel option for
each enabled counter. As the NMI handler is in-kernel, this avoids the problem.
</para>

</sect2>

</sect1>
 
<sect1 id="other-features">
<title>Other features</title>

<sect2 id="pidpgrpfilter">
<title>pid/pgrp filter</title>
<para>There are situations where you are only interested in the profiling results of a particular
running process, or process tty group. You can set
the pid/pgrp values via the <filename>--pid-filter</filename> and <filename>--pgrp-filter</filename>
options to <command>op_start</command>, which will make the daemon ignore samples for processes
that don't match the filter.
</para>
</sect2>

<sect2 id="unloadable">
<title>Unloading the kernel module</title>
<para>
The kernel module can be unloaded, but is designed to take very little memory when profiling is not underway.
There is no need to unload the module between profiler runs.
</para>
<para>
<command>lsmod</command> and similar utilities will still show the module's use count as <constant>-1</constant>.
However, this is not to be relied on - the module will become unloadable some short time after stopping profiling.
</para>
<para>
Note that by default module unloading is disabled when used on SMP systems. This is because of a small
chance of a module unload race crashing the kernel. As the race is very small, it is allowed to
re-enable the module unload by specifying the "allow_unload" parameter to the module :
</para>
<para><command>modprobe oprofile allow_unload=1</command></para>
<para>This option can be <emphasis>DANGEROUS</emphasis> and should only be used on non-production systems.</para> 
</sect2>

</sect1>
 
</chapter>

<chapter id="results">
<title>Obtaining results</title>
<para>
OK, so the profiler has been running, but it's not much use unless we can get some data out. Fairly often,
OProfile does a little <emphasis>too</emphasis> good a job of keeping overhead low, and no data reaches
the profiler. This can happen on lightly-loaded machines. Remember you can force a dump at any time with :
</para>
<para><command>op_dump</command></para>
<para>Remember to do this before complaining there is no profiling data !
Now that we've got some data, it has to be processed. That's the job of <command>oprofpp</command> or <command>op_to_source</command>.
This works on a sample file in the <filename>/var/lib/oprofile/samples/</filename> directory,
along with the binary file being profiled, to produce human-readable data. Note that if the binary file changes
after the sample file was created, you won't be able to get useful data out. This situation is detected for you.
Note that several instances of a binary are merged into one sample file. By default, all samples from a dynamically linked library
are merged into one sample file as well.
</para>
<para>
A different scenario happen when re-starting profiling with different parameters, as the old sample files from previous sessions don't
get deleted (allowing you to build profiles over many distinct profiling sessions).
If the last session is determined to be out of date due to the use of different profiling parameters, all the samples files are
backed up in a sub-directory name session-#nr.
If during profiling the daemon detects a change to a binary image and a samples file belonging to this binary exists, the samples file is silently deleted.
So if during profiling you change a binary it is your responsibility to save the binary image <emphasis>and</emphasis> the samples files, if 
you need it.
</para>
<para>
Note that kernel modules without symbol data (this can happen with some initrd setups) cannot be profiled (modules
with symbols show up in <filename>/proc/ksyms</filename>).
</para>

<sect1 id="post-profile-tools-common-options">
<title>common options to post-profile tools</title>
<para>
All post profile tools accept the following options
</para>
<variablelist>
	<varlistentry>
		<term><option>--help</option></term>
		<term><option>--usage</option></term>
		<term><option>-?</option></term>
		<listitem><para>
		Show the command line options.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--version</option></term>
		<term><option>-v</option></term>
		<listitem><para>
		Show the version number of oprofile on the form:
		</para>
<screen>
app_name:  oprofile 0.1cvs compiled on Mar  1 2002 20:40:40
</screen>
		</listitem>
	</varlistentry>
</variablelist>
</sect1>

<sect1 id="post-profiler">
<title><command>oprofpp</command> usage</title>
<para>
Oprofpp can be used in three major modes; list symbol mode, detailed symbol mode, or <command>gprof</command> mode.
The first gives sorted histogram output of sample counts against functions as shown in the walkthrough. The second
can show individual sample counts against instructions inside a function, useful for detailed profiling, whilst the
third mode is handy if you're used to <command>gprof</command> style output. Note that only flat <command>gprof</command>
profiles are supported, however.
</para>
<para>
Some interesting options of the post-processor :
</para>
<variablelist>
	<varlistentry>
		<term><option>--samples-file</option> <filename>filename</filename></term>
		<term><option>-f</option> <filename>filename</filename></term>
		<listitem><para>
		The samples file to use. By default, the current samples file for the given binary is used;
		this option can be used to examine older sample files.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--image-file</option> <filename>filename</filename></term>
		<term><option>-i</option> <filename>filename</filename></term>
		<listitem><para>
		The binary image (shared library, kernel vmlinux, or program) to produce data for.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--demangle</option></term>
		<term><option>-d</option></term>
		<listitem><para>
		Demangle C++ symbol names.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--counter</option> nr</term>
		<listitem><para>
		Which counter (0 - N) to extract information for. N is dependent on your cpu type: 1 for Intel CPUs, 3 for Athlon based CPUs.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--list-symbols</option></term>
		<term><option>-l</option></term>
		<listitem><para>
		List a histogram of sample counts against symbols. Each line shows the function name,
		its starting address, the relative percentage of hits across that image, and the absolute
		number of samples in this function.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--list-symbol</option> name</term>
		<term><option>-s</option> name</term>
		<listitem><para>
		Provide a detailed listing for the specified symbol name. This shows, for each sample,
		the position of the address, and the number of samples.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--dump-gprof-file filename</option></term>
		<term><option>-g filename</option></term>
		<listitem><para>
		Dump output to the specified file in <command>gprof</command> format. If you specify <filename>gmon.out</filename>,
		you can then call <command>gprof -p &lt;binary&gt;</command>.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--list-all-symbols-details</option></term>
		<term><option>-L</option></term>
		<listitem><para>
		Provide a detailed listing for all symbols. Each line shows number of samples at the given
		address for all counters.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--output-linenr-info</option></term>
		<term><option>-o</option></term>
		<listitem><para>
		Show the function and line number for all samples. This requires that the image was compiled
		with debug symbols (<option>-g</option>), and is
		usable only with --list-all-symbols-details, --list-symbol and --list-symbols.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--exclude-symbol</option> symbol[,symbol]</term>
		<term><option>-e</option> symbol[,symbol]</term>
		<listitem><para>
		Comma-separated list of symbols to ignore. This can be useful to ignore the leading contributors
		to the sample histogram, as the percentage values are re-calculated.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--show-shared-libs</option></term>
		<term><option>-k</option></term>
		<listitem><para>
		Show the details for each shared lib which belongs to the given application. This option is useful only
		if you have profiled with the <option>--separate-samples</option> option and you specify on the
		oprofpp command line either <option>--list-symbols</option> or 
		<option>--list-all-symbols-details</option>.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--output-format</option> vsSpPnlLiIh</term>
		<term><option>-t</option> vsSpPnlLiIh</term>
		<listitem><para>
		Specify the output format where a single format char is a field intended for: 'v' vma, 's'
		nr samples, 'S' nr cumulated samples, 'p' percent samples, 'P' cumulated percent samples,
		'n' symbol name, 'l' source file name and line nr, 'L' ditto as 'l' but with basename of source
		file name, 'i' image name, 'I' ditto as 'i' but with base name of image name, 'd' details for each samples for
		the selected symbols and 'h' for the header itself.
		This option is not available with --dump-gprof-file.
		</para></listitem>
	</varlistentry>
</variablelist>

</sect1>

<sect1 id="op-to-source">
<title><command>op_to_source</command>: Outputting annotated source</title>
<para>
<command>op_to_source</command> generates annotated source files or assembly listings optionally mixed with source.
If you want to see the source file the profiled application needs to have debug information and the source
must be available through this debug information e.g. compile the application with <option>-g</option> for 
<command>gcc</command>.
</para>
<para>
Note that for the reason explained in <xref linkend="hardware-counters" /> the results can show some
inaccuracy. The debug info itself can add other problems; for example, the line number for a symbol can be
incorrect. Assembly instructions can be re-ordered and moved by the compiler, and this can lead to
crediting source lines with samples not really "owned" by this line. Also see
<xref linkend="interpreting" />.
</para>
<para>
The options allowed are :
</para> 
<variablelist>
	<varlistentry>
		<term><option>--assembly</option></term>
		<term><option>-a</option></term>
		<listitem><para>
		<!-- FIXME: update if this changes -->
		Output assembly code. Currently the assembly code is sorted in increasing order on the vma
		address. The <option>--sort-by-counter</option>, <option>--with-more-than-samples percent_nr</option> and
		<option>--until-more-than-samples percent_nr</option> options can also be used with this
		option to provide filtering capabilities.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--source-dir</option> <filename>dirname</filename></term>
		<listitem><para>
		This option is used in conjunction with <option>--output-dir</option>. You
		can use it to specify the base directory of the source which you wish to produce
		annotated output for. With this option, any source files outside the directory
		(for example, system header files) are ignored.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--output-dir</option> <filename>dirname</filename></term>
		<listitem><para>
		Specify that you want to produce an annotated source tree, rather than getting all output to stdout. This
		creates a hierarchy of annotated source files, and is affected by the <option>--source-dir</option>,
		<option>--output</option>, and <option>--no-output</option> options.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--output patterns</option></term>
		<listitem><para>
		Specify a set of comma-separated patterns for matching annotated source output filenames.
		If this option is present, a file is only output if it matches one of the given
		patterns (which applies to the filename and each components of the containing directory names).
		For example :
		</para>
		<para>
		<command>--output '*.c,user.h'</command>
		</para>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--no-output patterns</option></term>
		<listitem><para>
		Specify a set of comma-separated patterns for filtering annotated source output filenames.
		If this option is present, a file is only output if it does not match one of the given
		patterns (which applies to the filename and each components of the containing directory names).
		For example :
		</para>
		<para>
		<command>--no-output 'boring.c,boring*.h'</command>
		</para>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--source-with-assembly</option></term>
		<term><option>-s</option></term>
		<listitem><para>
		Output assembly code mixed with the source file, implies <option>--assembly</option>.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--objdump-params</option></term>
		<term><option>-o</option></term>
		<listitem><para>
		pass the params strings directly to objdump allowing to pass additional parameters to objdump.
		Check the objdump man page to see what options objdump accept e.g. <option>-o '--disassembler-options=intel'</option>
		to get Intel assembly syntax instead of att syntax. This option can be used only with
		<option>--assembly</option> or <option>--source-with-assembly</option>
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--sort-by-counter counter_nr</option></term>
		<term><option>-c counter_nr</option></term>
		<listitem><para>
		Sort by decreasing number of samples on counter_nr. For assembly output this option provides only
		a filtering and not a sort order.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--with-more-than-samples percent_nr</option></term>
		<term><option>-w percent_nr</option></term>
		<listitem><para>
		Output source file which contains at least <option>percent_nr</option> samples.
		Can not be combined with <option>--until-more-than-samples</option>.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--until-more-than-samples percent_nr</option></term>
		<term><option>-m percent_nr</option></term>
		<listitem><para>
		Output source files until the amount of samples in these files reach percent_nr samples.
		Can not be combined with <option>--with-more-than-samples</option>.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--samples-file</option> <filename>filename</filename></term>
		<term><option>-f</option> <filename>filename</filename></term>
		<listitem><para>
		Specify the samples file. At least one of the <option>--samples-file</option> or
		<option>--image-file</option> must be specified.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--image-file</option>  <filename>filename</filename></term>
		<term><option>-i </option>  <filename>filename</filename></term>
		<listitem><para>
		Specify the image file.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--exclude-symbol</option> symbol[,symbol]</term>
		<term><option>-e</option> symbol[,symbol]</term>
		<listitem><para>
		Comma-separated list of symbols to ignore. This can be useful to ignore the leading contributors
		to the sample histogram, as the percentage values are re-calculated.
		</para></listitem>
	</varlistentry>
</variablelist>
</sect1>

<sect1 id="op-merge">
<title><command>op_merge</command>: merging samples files</title>
<para>
<command>op_merge</command> is used to merge samples wich belongs to the same binary image. Its main purpose
is to merge samples files created by profiling with --separate-samples. So you can create one samples
file containing all samples for a shared libs:
<command>op_merge</command><filename>/usr/lib/ld-2.1.2.so</filename> will create a samples file named
<filename>}usr}lib}ld-2.1.2.so</filename> ready to use with <command>oprofpp</command> or other post-profiling tools.
Additionally you can merge a subset of samples files inside one sample file by specifying explicitly the samples files name to merge.
This allows to use post-profile tools on shared libs for a subset of applications.
</para>
<para>
The options allowed are :
</para>
<variablelist>
	<varlistentry>
		<term><option>--use-counter</option> nr</term>
		<term><option>-c</option></term>
		<listitem><para>
		use counter nr to select the appropriate samples files
		</para></listitem>
	</varlistentry>
</variablelist>
</sect1>

<sect1 id="op-time">
<title><command>op_time</command>: Overall view of all system binaries</title>
<para>
You can get a quick look at an overall summary of relative binary profiles using <command>op_time</command>. This utility displays
the relative amount of samples for each application profiled sorted by decreasing order of samples count. So
with <command>op_time [<option>--option</option>] [<filename>image_name[,image_names]</filename>]</command> you can get :
</para>
<screen>
/lib/libc-2.1.2.so 19 32.7586%
/usr/X11R6/bin/XF86_SVGA 13 22.4138%
...
/usr/bin/grep 1 1.72414%
/usr/X11R6/lib/libXt.so.6.0 1 1.72414%
</screen>
<para>
If you don't specify any image_name on command line op_time report information about all profiled binary image.
You can use shell wildcards like :
<command>op_time <filename>/usr/bin/*</filename></command>
<!-- FIXME: remove this if implementation is fixed see op_time.cpp filter_image_name() -->
Currently you cannot use :
<command>op_time <filename>"/usr/bin/*"</filename></command>
</para>
<para>
Options allowed are :
</para> 
<variablelist>
	<varlistentry>
		<term><option>--use-counter</option> nr</term>
		<term><option>-c</option></term>
		<listitem><para>
		use counter nr for sorting samples count
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--show-shared-libs</option></term>
		<term><option>-k</option></term>
		<listitem><para>
		Show the details for each shared lib which belongs to one application. This option is
		useful only if you have profiled with the <option>--separate-samples</option> option.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--list-symbols</option></term>
		<term><option>-l</option></term>
		<listitem><para>
		Show details for each symbols in each profiled files
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--demangle</option></term>
		<term><option>-d</option></term>
		<listitem><para>
		demangle GNU C++ symbol names
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--show-image-name</option></term>
		<term><option>-n</option></term>
		<listitem><para>
		show the image name when specifying <option>--list-symbols</option>
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--reverse</option></term>
		<term><option>-r</option></term>
		<listitem><para>
		Sort by decreasing samples count instead of increasing count.
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--path</option> path list ',' separated</term>
		<term><option>-p</option> path list ',' separated</term>
		<listitem><para>
		Specify an alternate list of pathname to locate image file. This is usefull if your samples files
		name does not match the image file name such as module loaded at boot time through a ram disk
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--recursive-path</option> path list ',' separated</term>
		<term><option>-P</option> path list ',' separated</term>
		<listitem><para>
		Same as <option>mdash;</option> but retrieve recursively the image file name in the path list
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--output-format</option> vsSpPnlLiIh</term>
		<term><option>-t</option> vsSpPnlLiIh</term>
		<listitem><para>
		Specify the output format where a single format char is a field intended for: 'v' vma, 's'
		nr samples, 'S' nr cumulated samples, 'p' percent samples, 'P' cumulated percent samples,
		'n' symbol name, 'l' source file name and line nr, 'L' ditto as 'l' but with basename of source
		file name, 'i' image name, 'I' ditto as 'i' but with base name of image name, 'd' details for each samples for
		the selected symbols and 'h' for the header itself.
		This option is available only with --list-symbols
		</para></listitem>
	</varlistentry>
	<varlistentry>
		<term><option>--exclude-symbol</option> symbol[,symbol]</term>
		<term><option>-e</option> symbol[,symbol]</term>
		<listitem><para>
		Comma-separated list of symbols to ignore. This can be useful to ignore the leading contributors
		to the sample histogram, as the percentage values are re-calculated.
		</para></listitem>
	</varlistentry>
</variablelist>
</sect1>
</chapter>

<chapter id="interpreting">
<title>Interpreting profiling results</title>
<para>
Another grey art. The standard caveats of profiling come
to mind: profile realistic situations, profile difference scenarios, profile
for as long as a time as possible, avoid system-specific artifacts, don't trust
the profile data too much. Also bear in mind the comments on the performance
counters above - you can <emphasis>not</emphasis> rely on totally accurate
instruction-level profiling.  However, for almost all circumstances the data
can be useful. Ideally a utility such as Intel's VTUNE would be available to
allow careful instruction-level analysis; go hassle Intel for this, not me ;)
</para>
<sect1 id="irq-latency">
<title>Profiling interrupt latency</title>
<para>
This is an example of how the latency of delivery of profiling interrupts
can impact the reliability of the profiling data. This is pretty much a 
worst-case-scenario example: these problems are fairly rare.
</para>
<screen>
double fun(double a, double b, double c)
{
 double result = 0;
 for (int i = 0 ; i &lt; 10000; ++i) {
  result += a;
  result *= b;
  result /= c;
 }
 return result;
}
</screen>
<para>
Here the last instruction of the loop is very costly, and you would expect the result
reflecting that - but (cutting the instructions inside the loop):
</para>
<screen>
$ op_to_source -a -w 10

 /* 9349 0.3788% */
 8048394:       fadd   %st(3),%st
 /* 22858 0.9261% */
 8048396:       fmul   %st(2),%st
 /* 687682 27.86% */
 8048398:       fdiv   %st(1),%st
 /* 1747822 70.81% */
 804839a:       decl   %eax
 /* 17 0.0006887% */
 804839b:       jns    8048394
</screen>
<para>
The problem comes from the x86 hardware; when the counter overflows the IRQ line
is asserted but the hardware have features that can delay the NMI interrupt:
x86 hardware is synchronous (e.g. can not interrupt during an instruction but
interrupt at the end of instruction), there is also a latency when the IRQ
line is asserted the hardware can take some cycles to get account; the multiple
execution unit and the out of order model of modern x86 family also causes
problems. The following shows the same function at source level
</para>
<screen>
$op_to_source -a -w 10 show

double fun(double a, double b, double c)
/* fun(double, double, double) 2468162 100% */
/* 165 0.006685% */
{
        /* 3 0.0001215% */
        double result = 0;
        for (int i = 0 ; i &lt; 10000; ++i) {
                /* 9349 0.3788% */
                result += a;
                /* 22858 0.9261% */
                result *= b;
                /* 687682 27.86% */
                result /= c;
        /* 1747918 70.82% */
        }
        return result;
/* 187 0.007576% */
}
</screen>
<para>
So the conclusion: don't trust samples coming at the end of a loop,
particularly if the last instruction generated by the compiler is costly, this
case can occur also for each branch in your program. Always bear in mind that samples
can be often delayed by a few cycles from its real position. That's a hardware
problem and oprofile can do nothing about it.
</para>
</sect1>
<sect1 id="debug-info">
<title>Inaccuracies in annotated source</title>
<para>
The compiler can introduce some pitfalls in the annotated source output.
The optimizer can move pieces of code in such manner that two line of codes
are interlaced (instruction scheduling). Also debug info generated by the compiler 
can show strange behavior. This is especially true for complex expressions e.g. inside
an if statement:
</para>
<screen>
	if (a &amp;&amp; ..
	    b &amp;&amp; ..
	    c &amp;&amp;)
</screen>
<para>
here the problem come from the position of line number. The available debug
info does not give enough details for the if condition, so all samples are
accumulated at the position of the right brace of the expression. Using
<command>op_to_source <option>-a</option></command> can help to show the real
samples at an assembly level.
</para>
</sect1>
<!-- FIXME: the wording is perhaps awkward for this section -->
<!-- FIXME: an entry of the FAQ must point here ? -->
<sect1 id="symbol-without-debug-info">
<title>Assembly function</title>
<para>
Often assembler can not generate debug information automatically. Such example of commonly used assembler is
<command>gas</command> and <command>nasm</command>. This means than you can not get source report unless 
you manually define the neccessary debug information, report to your assembler documentation for that. The only
debugging info needed currently by oprofile is the linenr/filename vma association. When profiling assembly
without debugging info you can always get report for symbol and optionnaly for vma through <command>oprofpp -l</command>
or <command>oprofpp -L</command> but this work only for symbol with the right attribute.
For gas you can get this by
</para>
<screen>
.globl foo
	.type	foo,@function
</screen>
<para> 
while for nasm you must use
</para>
<screen>
	  GLOBAL foo:function		; [1]
</screen>
<para>
Note than oprofile do not need the global attribute, but only the function attribute. User of gas and nasm
must found the right way to not declare the foo symbol global if necessary.
</para>
</sect1>
<!-- 

FIXME: I commented this bit out until we've written something ...

improve this ? but look first why this file is special 
<sect2 id="small-functions">
<title>Small functions</title>
<para>
Very small functions can show strange behavior. The file in your source
directory of oprofile <filename>$SRC/test-oprofile/understanding/puzzle.c</filename>
show such example
</para>
</sect2>
--> 
<sect1 id="hidden-cost">
<title>Other discrepancies</title>
<para>
Another cause of apparent problems is the hidden cost of instructions. A very
common example is two memory reads: one from L1 cache and the other from memory.
It's clear for all people than the second memory read will show more samples
but there are many other causes of hidden cost of instructions. A non-exhaustive
list: mis-predicted branch, TLB cache miss, partial register stall,
partial register dependencies, memory mismatch stall, re-executed ops. If you want to write
programs at assembly level, or you write compiler take a look at the Intel and
AMD documentation at <ulink url="http://developer.intel.com/">http://developer.intel.com/</ulink>
and <ulink url="http://www.amd.com/products/cpg/athlon/techdocs/">http://www.amd.com/products/cpg/athlon/techdocs/</ulink>.
</para>
</sect1>
<!-- 

FIXME: we should document how samples can be lost by the daemon, and why not to worry
 
FIXME: more examples, basic and advanced trick. A howto use utilities FAQ ?

The FAQ must use <sect1> and imbricated <sect2> to fit in only one page.
It is possible through release to put the FAQ (or the whole doc ?) on sourceforge ?

yes, indeed. We can do this bit by bit though, as long as we've done as much
as we can for release 1.0 - john
 
List for how to :

o how to get library samples (separate-samples) 
o how to get module / kernel post-prof
o how to use sudo (and risks !)
o more ...
 
<sect2 id="none">
<title>and more</title>
<para>
</para>
</sect2>
--> 
</chapter>

<chapter id="overhead">
<title>Profiling overhead</title>
<para>
One of the major design criterion for OProfile was low overhead. In many cases
profiling is hardly noticeable in terms of overhead (I regularly leave it turned on
all the time). It achieves this by judicious use of kernel-side data structures
to reduce the analysis overhead to a bare runtime minimum. There are several things
that unfortunately complicate the issue, so there are cases where the overhead is
noticeable.
</para>
<para>
The worst-case scenario is where there are many short-lived processes. This can be seen
in a kernel compile, for instance. This leads to hash table clashes; clashes lead to faster
buffer filling; buffer filling leads to higher overhead. Even in this worst case overhead
is low compared to other profilers; only very detailed profiling of these workloads
has an overhead of higher than 5%. Actual performance
data is presented in the source distribution. In fact most situations have much fewer
numbers of processes, leading to far better performance.
</para>
<para>Some graphs of performance characteristics of oprofile are available on the website
 - see <xref linkend="resources" />.
</para>
</chapter>

<chapter id="ack">
<title>Acknowledgments</title>
<para>
Thanks to (in no particular order) : Arjan van de Ven, Rik van Riel, Juan Quintela, Philippe Elie,
Phillipp Rumpf, Tigran Aivazian, Alex Brown, Alisdair Rawsthorne, Bob Montgomery, Ray Bryant, H.J. Lu,
Jeff Esper, Will Cohen, Cliff Woolley, Alex Tsariounov, Al Stone,
Richard Reich (rreich@rdrtech.com), Dave Jones, Charles Filtness; and finally Pulp, for "Intro".
</para>
</chapter>

</book>
